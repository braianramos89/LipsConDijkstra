(defun bellman-ford (matrix num-nodes source)
  (let ((distances (make-list num-nodes :initial-element most-positive-fixnum))
        (predecessors (make-list num-nodes :initial-element nil)))
    (setf (nth source distances) 0)

    (dotimes (_ (1- num-nodes))
      (dotimes (u num-nodes)
        (dotimes (v num-nodes)
          (let ((weight (nth v (nth u matrix))))
            (let ((alt (+ (nth u distances) weight)))
              (when (and (< (nth u distances) most-positive-fixnum) (< alt (nth v distances)))
                (setf (nth v distances) alt)
                (setf (nth v predecessors) u)))))))

    (print-results distances predecessors)))

(defun print-results (distances predecessors)
  (format t "Nodo\tDistancia desde fuente\tCamino~%")
  (dotimes (i (length distances))
    (let ((dist (nth i distances))
          (path (reconstruct-path i predecessors)))
      (format t "~A\t~A\t\t~A~%" i dist
              (if path (format nil "~{~A -> ~}~A" path) "N/A")))))

(defun reconstruct-path (node predecessors)
  (defun recurse (n acc)
    (if (null n)
        acc
        (recurse (nth n predecessors) (cons n acc))))
  
  (let ((path (recurse node nil)))
    (if (null path)
        nil ; Devolver una lista vacía en lugar de "N/A"
        path)))

;; Ejemplo de uso con medición del tiempo de ejecución
(let* ((matrix '((0 4 2 0 0)
                 (4 0 1 5 0)
                 (2 1 0 8 10)
                 (0 5 8 0 2)
                 (0 0 10 2 0)))
       (num-nodes (length matrix))
       (source 0)
       (start-time (get-internal-real-time)))
  (bellman-ford matrix num-nodes source)
  (format t "Tiempo de ejecución: ~A segundos~%" (/ (- (get-internal-real-time) start-time) internal-time-units-per-second)))
